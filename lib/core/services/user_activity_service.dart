import 'package:flutter/foundation.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart' as firebase_auth;
import 'package:cloud_functions/cloud_functions.dart';

/// User activity model - synced to Firestore
class UserActivity {
  final String id;
  final String userId;
  final String activityType; // 'view', 'search', 'add_to_cart', 'purchase', 'review', 'wishlist'
  final String? productId;
  final String? productName;
  final String? category;
  final double? price;
  final int? quantity;
  final Map<String, dynamic>? metadata;
  final DateTime timestamp;
  final String? sessionId;

  UserActivity({
    required this.id,
    required this.userId,
    required this.activityType,
    this.productId,
    this.productName,
    this.category,
    this.price,
    this.quantity,
    this.metadata,
    required this.timestamp,
    this.sessionId,
  });

  Map<String, dynamic> toFirestore() => {
    'userId': userId,
    'activityType': activityType,
    'productId': productId,
    'productName': productName,
    'category': category,
    'price': price,
    'quantity': quantity,
    'metadata': metadata,
    'timestamp': Timestamp.fromDate(timestamp),
    'sessionId': sessionId,
  };

  factory UserActivity.fromFirestore(DocumentSnapshot doc) {
    final data = doc.data() as Map<String, dynamic>;
    return UserActivity(
      id: doc.id,
      userId: data['userId'] ?? '',
      activityType: data['activityType'] ?? 'unknown',
      productId: data['productId'],
      productName: data['productName'],
      category: data['category'],
      price: (data['price'] as num?)?.toDouble(),
      quantity: data['quantity'],
      metadata: data['metadata'],
      timestamp: (data['timestamp'] as Timestamp?)?.toDate() ?? DateTime.now(),
      sessionId: data['sessionId'],
    );
  }
}

/// User behavior aggregation (daily summary)
class UserBehaviorSummary {
  final String userId;
  final DateTime date;
  final int viewCount;
  final int searchCount;
  final int cartAddCount;
  final int purchaseCount;
  final double totalSpent;
  final List<String> categoriesViewed; // Unique categories
  final List<String> topProducts; // Most viewed
  final double timeSpentMinutes;

  UserBehaviorSummary({
    required this.userId,
    required this.date,
    required this.viewCount,
    required this.searchCount,
    required this.cartAddCount,
    required this.purchaseCount,
    required this.totalSpent,
    required this.categoriesViewed,
    required this.topProducts,
    required this.timeSpentMinutes,
  });

  Map<String, dynamic> toFirestore() => {
    'userId': userId,
    'date': Timestamp.fromDate(date),
    'viewCount': viewCount,
    'searchCount': searchCount,
    'cartAddCount': cartAddCount,
    'purchaseCount': purchaseCount,
    'totalSpent': totalSpent,
    'categoriesViewed': categoriesViewed,
    'topProducts': topProducts,
    'timeSpentMinutes': timeSpentMinutes,
  };

  factory UserBehaviorSummary.fromFirestore(DocumentSnapshot doc) {
    final data = doc.data() as Map<String, dynamic>;
    return UserBehaviorSummary(
      userId: data['userId'] ?? '',
      date: (data['date'] as Timestamp?)?.toDate() ?? DateTime.now(),
      viewCount: data['viewCount'] ?? 0,
      searchCount: data['searchCount'] ?? 0,
      cartAddCount: data['cartAddCount'] ?? 0,
      purchaseCount: data['purchaseCount'] ?? 0,
      totalSpent: (data['totalSpent'] as num?)?.toDouble() ?? 0.0,
      categoriesViewed: List<String>.from(data['categoriesViewed'] ?? []),
      topProducts: List<String>.from(data['topProducts'] ?? []),
      timeSpentMinutes: (data['timeSpentMinutes'] as num?)?.toDouble() ?? 0.0,
    );
  }
}

/// Handles all user activity tracking and persistence to Firestore
class UserActivityService {
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;
  final firebase_auth.FirebaseAuth _auth = firebase_auth.FirebaseAuth.instance;

  String? _sessionId;

  UserActivityService() {
    _sessionId = _generateSessionId();
  }

  /// Generate unique session ID for this app session
  String _generateSessionId() {
    return '${DateTime.now().millisecondsSinceEpoch}-${(DateTime.now().microsecond % 1000)}';
  }

  /// Get current user ID
  String? _getCurrentUserId() {
    return _auth.currentUser?.uid;
  }

  /// Log product view
  Future<void> logProductView({
    required String productId,
    required String productName,
    required String category,
    required double price,
  }) async {
    final userId = _getCurrentUserId();
    if (userId == null) return; // Skip if not authenticated

    try {
      // Log locally to Firestore
      await _firestore.collection('user_activities').add(UserActivity(
        id: '', // Will be generated by Firestore
        userId: userId,
        activityType: 'view',
        productId: productId,
        productName: productName,
        category: category,
        price: price,
        timestamp: DateTime.now(),
        sessionId: _sessionId,
      ).toFirestore());

      // Also update behavior summary
      await _updateBehaviorSummary(userId, 'view', category: category);

      // Call Cloud Function to update trending and prepare for recommendations
      try {
        await FirebaseFunctions.instance
            .httpsCallable('logProductView')
            .call({
          'productId': productId,
          'productName': productName,
          'category': category,
          'price': price,
        });
        debugPrint('✅ Product view logged to backend: $productName');
      } catch (cloudFunctionError) {
        debugPrint(
            '⚠️ Cloud Function call failed (non-critical): $cloudFunctionError');
        // Don't throw - local logging already succeeded
      }
    } catch (e) {
      debugPrint('❌ Error logging product view: $e');
    }
  }

  /// Log search query
  Future<void> logSearch({
    required String query,
    required int resultsCount,
    required String? category,
  }) async {
    final userId = _getCurrentUserId();
    if (userId == null) return;

    try {
      await _firestore.collection('user_activities').add(UserActivity(
        id: '',
        userId: userId,
        activityType: 'search',
        category: category,
        metadata: {
          'query': query,
          'resultsCount': resultsCount,
        },
        timestamp: DateTime.now(),
        sessionId: _sessionId,
      ).toFirestore());

      await _updateBehaviorSummary(userId, 'search', category: category);
    } catch (e) {
      debugPrint('❌ Error logging search: $e');
    }
  }

  /// Log add to cart
  Future<void> logAddToCart({
    required String productId,
    required String productName,
    required String category,
    required double price,
    required int quantity,
  }) async {
    final userId = _getCurrentUserId();
    if (userId == null) return;

    try {
      await _firestore.collection('user_activities').add(UserActivity(
        id: '',
        userId: userId,
        activityType: 'add_to_cart',
        productId: productId,
        productName: productName,
        category: category,
        price: price,
        quantity: quantity,
        timestamp: DateTime.now(),
        sessionId: _sessionId,
      ).toFirestore());

      await _updateBehaviorSummary(userId, 'cart_add', category: category);
    } catch (e) {
      debugPrint('❌ Error logging add to cart: $e');
    }
  }

  /// Log purchase
  Future<void> logPurchase({
    required String orderId,
    required List<String> productIds,
    required List<String> productNames,
    required double totalAmount,
    required List<String> categories,
  }) async {
    final userId = _getCurrentUserId();
    if (userId == null) return;

    try {
      // Log purchase activity
      await _firestore.collection('user_activities').add(UserActivity(
        id: '',
        userId: userId,
        activityType: 'purchase',
        metadata: {
          'orderId': orderId,
          'productCount': productIds.length,
          'totalAmount': totalAmount,
          'productIds': productIds,
          'productNames': productNames,
        },
        timestamp: DateTime.now(),
        sessionId: _sessionId,
      ).toFirestore());

      // Update user purchase history
      await _updateUserPurchaseHistory(userId, orderId, productIds, totalAmount);

      // Update behavior summary
      await _updateBehaviorSummary(userId, 'purchase', amount: totalAmount, categories: categories);
    } catch (e) {
      debugPrint('❌ Error logging purchase: $e');
    }
  }

  /// Log add to wishlist
  Future<void> logAddToWishlist({
    required String productId,
    required String productName,
    required String category,
    required double price,
  }) async {
    final userId = _getCurrentUserId();
    if (userId == null) return;

    try {
      await _firestore.collection('user_activities').add(UserActivity(
        id: '',
        userId: userId,
        activityType: 'wishlist',
        productId: productId,
        productName: productName,
        category: category,
        price: price,
        timestamp: DateTime.now(),
        sessionId: _sessionId,
      ).toFirestore());

      await _updateBehaviorSummary(userId, 'wishlist', category: category);
    } catch (e) {
      debugPrint('❌ Error logging wishlist: $e');
    }
  }

  /// Log product review
  Future<void> logProductReview({
    required String productId,
    required String productName,
    required String category,
    required double rating,
    required String reviewText,
  }) async {
    final userId = _getCurrentUserId();
    if (userId == null) return;

    try {
      await _firestore.collection('user_activities').add(UserActivity(
        id: '',
        userId: userId,
        activityType: 'review',
        productId: productId,
        productName: productName,
        category: category,
        metadata: {
          'rating': rating,
          'reviewText': reviewText,
        },
        timestamp: DateTime.now(),
        sessionId: _sessionId,
      ).toFirestore());

      await _updateBehaviorSummary(userId, 'review');
    } catch (e) {
      debugPrint('❌ Error logging review: $e');
    }
  }

  /// Get user's activity history (for recommendations)
  Future<List<UserActivity>> getUserActivityHistory({
    required String userId,
    int limit = 100,
    String? activityType,
  }) async {
    try {
      Query query = _firestore
          .collection('user_activities')
          .where('userId', isEqualTo: userId)
          .orderBy('timestamp', descending: true)
          .limit(limit);

      if (activityType != null) {
        query = query.where('activityType', isEqualTo: activityType);
      }

      final snapshot = await query.get();
      return snapshot.docs
          .map((doc) => UserActivity.fromFirestore(doc))
          .toList();
    } catch (e) {
      debugPrint('❌ Error fetching activity history: $e');
      return [];
    }
  }

  /// Get user behavior summary for today
  Future<UserBehaviorSummary?> getTodayBehaviorSummary(String userId) async {
    try {
      final today = DateTime.now();
      final startOfDay = DateTime(today.year, today.month, today.day);
      final endOfDay = DateTime(today.year, today.month, today.day, 23, 59, 59);

      final snapshot = await _firestore
          .collection('user_behavior_summaries')
          .where('userId', isEqualTo: userId)
          .where('date', isGreaterThanOrEqualTo: Timestamp.fromDate(startOfDay))
          .where('date', isLessThanOrEqualTo: Timestamp.fromDate(endOfDay))
          .limit(1)
          .get();

      if (snapshot.docs.isNotEmpty) {
        return UserBehaviorSummary.fromFirestore(snapshot.docs.first);
      }
      return null;
    } catch (e) {
      debugPrint('❌ Error fetching behavior summary: $e');
      return null;
    }
  }

  /// Update behavior summary document
  Future<void> _updateBehaviorSummary(
    String userId,
    String activity, {
    String? category,
    double? amount,
    List<String>? categories,
  }) async {
    try {
      final today = DateTime.now();
      final docId = '${userId}_${today.year}${today.month}${today.day}';

      final docRef = _firestore.collection('user_behavior_summaries').doc(docId);
      final doc = await docRef.get();

      if (!doc.exists) {
        // Create new summary
        await docRef.set(UserBehaviorSummary(
          userId: userId,
          date: DateTime(today.year, today.month, today.day),
          viewCount: activity == 'view' ? 1 : 0,
          searchCount: activity == 'search' ? 1 : 0,
          cartAddCount: activity == 'cart_add' ? 1 : 0,
          purchaseCount: activity == 'purchase' ? 1 : 0,
          totalSpent: amount ?? 0,
          categoriesViewed: category != null ? [category] : [],
          topProducts: [],
          timeSpentMinutes: 0,
        ).toFirestore());
      } else {
        // Update existing summary
        final summary = UserBehaviorSummary.fromFirestore(doc);
        
        int newViewCount = summary.viewCount + (activity == 'view' ? 1 : 0);
        int newSearchCount = summary.searchCount + (activity == 'search' ? 1 : 0);
        int newCartCount = summary.cartAddCount + (activity == 'cart_add' ? 1 : 0);
        int newPurchaseCount = summary.purchaseCount + (activity == 'purchase' ? 1 : 0);
        double newTotal = summary.totalSpent + (amount ?? 0);

        List<String> newCategories = [...summary.categoriesViewed];
        if (category != null && !newCategories.contains(category)) {
          newCategories.add(category);
        }
        if (categories != null) {
          for (final cat in categories) {
            if (!newCategories.contains(cat)) {
              newCategories.add(cat);
            }
          }
        }

        await docRef.update({
          'viewCount': newViewCount,
          'searchCount': newSearchCount,
          'cartAddCount': newCartCount,
          'purchaseCount': newPurchaseCount,
          'totalSpent': newTotal,
          'categoriesViewed': newCategories,
        });
      }
    } catch (e) {
      debugPrint('❌ Error updating behavior summary: $e');
    }
  }

  /// Update user purchase history for quick access
  Future<void> _updateUserPurchaseHistory(
    String userId,
    String orderId,
    List<String> productIds,
    double totalAmount,
  ) async {
    try {
      await _firestore.collection('user_purchase_history').doc(userId).update({
        'totalPurchases': FieldValue.increment(1),
        'totalSpent': FieldValue.increment(totalAmount),
        'lastPurchaseDate': Timestamp.now(),
        'recentOrders': FieldValue.arrayUnion([orderId]),
        'purchasedProductIds': FieldValue.arrayUnion(productIds),
      }).catchError((_) async {
        // Create new document if it doesn't exist
        await _firestore.collection('user_purchase_history').doc(userId).set({
          'userId': userId,
          'totalPurchases': 1,
          'totalSpent': totalAmount,
          'firstPurchaseDate': Timestamp.now(),
          'lastPurchaseDate': Timestamp.now(),
          'recentOrders': [orderId],
          'purchasedProductIds': productIds,
        });
      });
    } catch (e) {
      debugPrint('❌ Error updating purchase history: $e');
    }
  }

  /// Get recommended products based on user activity
  Future<List<String>> getRecommendedProducts({
    required String userId,
    int limit = 10,
  }) async {
    try {
      // Get user's most viewed categories
      final summary = await getTodayBehaviorSummary(userId);
      if (summary == null || summary.categoriesViewed.isEmpty) {
        return [];
      }

      // Get products from those categories that user hasn't viewed
      final activities = await getUserActivityHistory(userId: userId, limit: 500);
      final viewedProductIds = activities
          .where((a) => a.activityType == 'view')
          .map((a) => a.productId)
          .whereType<String>()
          .toSet();

      // Query recommended products
      final snapshot = await _firestore
          .collection('products')
          .where('category', whereIn: summary.categoriesViewed)
          .limit(limit * 2)
          .get();

      return snapshot.docs
          .map((doc) => doc.id)
          .where((id) => !viewedProductIds.contains(id))
          .take(limit)
          .toList();
    } catch (e) {
      debugPrint('❌ Error getting recommended products: $e');
      return [];
    }
  }

  /// Get user's frequently purchased categories
  Future<List<String>> getFavoriteCategories(String userId) async {
    try {
      final purchases = await getUserActivityHistory(
        userId: userId,
        limit: 100,
        activityType: 'purchase',
      );

      final categories = <String, int>{};
      for (final activity in purchases) {
        if (activity.category != null) {
          categories[activity.category!] = (categories[activity.category] ?? 0) + 1;
        }
      }

      // Sort by frequency
      final sorted = categories.entries.toList()
        ..sort((a, b) => b.value.compareTo(a.value));

      return sorted.map((e) => e.key).take(5).toList();
    } catch (e) {
      debugPrint('❌ Error getting favorite categories: $e');
      return [];
    }
  }
}
